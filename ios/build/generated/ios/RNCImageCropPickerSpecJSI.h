/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - RNCImageCropPickerBasePickerOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19, typename P20>
struct [[deprecated("Use RNCImageCropPickerPickerOptions instead.")]] RNCImageCropPickerBasePickerOptions {
  P0 mediaType;
  P1 multiple;
  P2 includeBase64;
  P3 includeExif;
  P4 cropping;
  P5 width;
  P6 height;
  P7 cropperActiveWidgetColor;
  P8 cropperStatusBarLight;
  P9 cropperNavigationBarLight;
  P10 cropperToolbarColor;
  P11 cropperToolbarTitle;
  P12 cropperToolbarWidgetColor;
  P13 cropperCircleOverlay;
  P14 freeStyleCropEnabled;
  P15 showCropGuidelines;
  P16 showCropFrame;
  P17 hideBottomControls;
  P18 enableRotationGesture;
  P19 disableCropperColorSetters;
  P20 useFrontCamera;
  bool operator==(const RNCImageCropPickerBasePickerOptions &other) const {
    return mediaType == other.mediaType && multiple == other.multiple && includeBase64 == other.includeBase64 && includeExif == other.includeExif && cropping == other.cropping && width == other.width && height == other.height && cropperActiveWidgetColor == other.cropperActiveWidgetColor && cropperStatusBarLight == other.cropperStatusBarLight && cropperNavigationBarLight == other.cropperNavigationBarLight && cropperToolbarColor == other.cropperToolbarColor && cropperToolbarTitle == other.cropperToolbarTitle && cropperToolbarWidgetColor == other.cropperToolbarWidgetColor && cropperCircleOverlay == other.cropperCircleOverlay && freeStyleCropEnabled == other.freeStyleCropEnabled && showCropGuidelines == other.showCropGuidelines && showCropFrame == other.showCropFrame && hideBottomControls == other.hideBottomControls && enableRotationGesture == other.enableRotationGesture && disableCropperColorSetters == other.disableCropperColorSetters && useFrontCamera == other.useFrontCamera;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19, typename P20>
struct [[deprecated("Use RNCImageCropPickerPickerOptionsBridging instead.")]] RNCImageCropPickerBasePickerOptionsBridging {
  static RNCImageCropPickerBasePickerOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    RNCImageCropPickerBasePickerOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "mediaType"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "multiple"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "includeBase64"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "includeExif"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "cropping"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "cropperActiveWidgetColor"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "cropperStatusBarLight"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "cropperNavigationBarLight"), jsInvoker),
      bridging::fromJs<P10>(rt, value.getProperty(rt, "cropperToolbarColor"), jsInvoker),
      bridging::fromJs<P11>(rt, value.getProperty(rt, "cropperToolbarTitle"), jsInvoker),
      bridging::fromJs<P12>(rt, value.getProperty(rt, "cropperToolbarWidgetColor"), jsInvoker),
      bridging::fromJs<P13>(rt, value.getProperty(rt, "cropperCircleOverlay"), jsInvoker),
      bridging::fromJs<P14>(rt, value.getProperty(rt, "freeStyleCropEnabled"), jsInvoker),
      bridging::fromJs<P15>(rt, value.getProperty(rt, "showCropGuidelines"), jsInvoker),
      bridging::fromJs<P16>(rt, value.getProperty(rt, "showCropFrame"), jsInvoker),
      bridging::fromJs<P17>(rt, value.getProperty(rt, "hideBottomControls"), jsInvoker),
      bridging::fromJs<P18>(rt, value.getProperty(rt, "enableRotationGesture"), jsInvoker),
      bridging::fromJs<P19>(rt, value.getProperty(rt, "disableCropperColorSetters"), jsInvoker),
      bridging::fromJs<P20>(rt, value.getProperty(rt, "useFrontCamera"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String mediaTypeToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static bool multipleToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static bool includeBase64ToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static bool includeExifToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static bool croppingToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperActiveWidgetColorToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperStatusBarLightToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperNavigationBarLightToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarColorToJs(jsi::Runtime &rt, P10 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarTitleToJs(jsi::Runtime &rt, P11 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarWidgetColorToJs(jsi::Runtime &rt, P12 value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperCircleOverlayToJs(jsi::Runtime &rt, P13 value) {
    return bridging::toJs(rt, value);
  }

  static bool freeStyleCropEnabledToJs(jsi::Runtime &rt, P14 value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropGuidelinesToJs(jsi::Runtime &rt, P15 value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropFrameToJs(jsi::Runtime &rt, P16 value) {
    return bridging::toJs(rt, value);
  }

  static bool hideBottomControlsToJs(jsi::Runtime &rt, P17 value) {
    return bridging::toJs(rt, value);
  }

  static bool enableRotationGestureToJs(jsi::Runtime &rt, P18 value) {
    return bridging::toJs(rt, value);
  }

  static bool disableCropperColorSettersToJs(jsi::Runtime &rt, P19 value) {
    return bridging::toJs(rt, value);
  }

  static bool useFrontCameraToJs(jsi::Runtime &rt, P20 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const RNCImageCropPickerBasePickerOptions<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.mediaType) {
      result.setProperty(rt, "mediaType", bridging::toJs(rt, value.mediaType.value(), jsInvoker));
    }
    if (value.multiple) {
      result.setProperty(rt, "multiple", bridging::toJs(rt, value.multiple.value(), jsInvoker));
    }
    if (value.includeBase64) {
      result.setProperty(rt, "includeBase64", bridging::toJs(rt, value.includeBase64.value(), jsInvoker));
    }
    if (value.includeExif) {
      result.setProperty(rt, "includeExif", bridging::toJs(rt, value.includeExif.value(), jsInvoker));
    }
    if (value.cropping) {
      result.setProperty(rt, "cropping", bridging::toJs(rt, value.cropping.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.height) {
      result.setProperty(rt, "height", bridging::toJs(rt, value.height.value(), jsInvoker));
    }
    if (value.cropperActiveWidgetColor) {
      result.setProperty(rt, "cropperActiveWidgetColor", bridging::toJs(rt, value.cropperActiveWidgetColor.value(), jsInvoker));
    }
    if (value.cropperStatusBarLight) {
      result.setProperty(rt, "cropperStatusBarLight", bridging::toJs(rt, value.cropperStatusBarLight.value(), jsInvoker));
    }
    if (value.cropperNavigationBarLight) {
      result.setProperty(rt, "cropperNavigationBarLight", bridging::toJs(rt, value.cropperNavigationBarLight.value(), jsInvoker));
    }
    if (value.cropperToolbarColor) {
      result.setProperty(rt, "cropperToolbarColor", bridging::toJs(rt, value.cropperToolbarColor.value(), jsInvoker));
    }
    if (value.cropperToolbarTitle) {
      result.setProperty(rt, "cropperToolbarTitle", bridging::toJs(rt, value.cropperToolbarTitle.value(), jsInvoker));
    }
    if (value.cropperToolbarWidgetColor) {
      result.setProperty(rt, "cropperToolbarWidgetColor", bridging::toJs(rt, value.cropperToolbarWidgetColor.value(), jsInvoker));
    }
    if (value.cropperCircleOverlay) {
      result.setProperty(rt, "cropperCircleOverlay", bridging::toJs(rt, value.cropperCircleOverlay.value(), jsInvoker));
    }
    if (value.freeStyleCropEnabled) {
      result.setProperty(rt, "freeStyleCropEnabled", bridging::toJs(rt, value.freeStyleCropEnabled.value(), jsInvoker));
    }
    if (value.showCropGuidelines) {
      result.setProperty(rt, "showCropGuidelines", bridging::toJs(rt, value.showCropGuidelines.value(), jsInvoker));
    }
    if (value.showCropFrame) {
      result.setProperty(rt, "showCropFrame", bridging::toJs(rt, value.showCropFrame.value(), jsInvoker));
    }
    if (value.hideBottomControls) {
      result.setProperty(rt, "hideBottomControls", bridging::toJs(rt, value.hideBottomControls.value(), jsInvoker));
    }
    if (value.enableRotationGesture) {
      result.setProperty(rt, "enableRotationGesture", bridging::toJs(rt, value.enableRotationGesture.value(), jsInvoker));
    }
    if (value.disableCropperColorSetters) {
      result.setProperty(rt, "disableCropperColorSetters", bridging::toJs(rt, value.disableCropperColorSetters.value(), jsInvoker));
    }
    if (value.useFrontCamera) {
      result.setProperty(rt, "useFrontCamera", bridging::toJs(rt, value.useFrontCamera.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - RNCImageCropPickerBasePickerResponse

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct [[deprecated("Use RNCImageCropPickerPickerResponse instead.")]] RNCImageCropPickerBasePickerResponse {
  P0 path;
  P1 localIdentifier;
  P2 sourceURL;
  P3 filename;
  P4 width;
  P5 height;
  P6 mime;
  P7 size;
  P8 duration;
  P9 data;
  P10 exif;
  P11 cropRect;
  P12 creationDate;
  P13 modificationDate;
  bool operator==(const RNCImageCropPickerBasePickerResponse &other) const {
    return path == other.path && localIdentifier == other.localIdentifier && sourceURL == other.sourceURL && filename == other.filename && width == other.width && height == other.height && mime == other.mime && size == other.size && duration == other.duration && data == other.data && exif == other.exif && cropRect == other.cropRect && creationDate == other.creationDate && modificationDate == other.modificationDate;
  }
};

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct [[deprecated("Use RNCImageCropPickerPickerResponseBridging instead.")]] RNCImageCropPickerBasePickerResponseBridging {
  static RNCImageCropPickerBasePickerResponse<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    RNCImageCropPickerBasePickerResponse<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> result{
      bridging::fromJs<P0>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<P1>(rt, value.getProperty(rt, "localIdentifier"), jsInvoker),
      bridging::fromJs<P2>(rt, value.getProperty(rt, "sourceURL"), jsInvoker),
      bridging::fromJs<P3>(rt, value.getProperty(rt, "filename"), jsInvoker),
      bridging::fromJs<P4>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<P5>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<P6>(rt, value.getProperty(rt, "mime"), jsInvoker),
      bridging::fromJs<P7>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<P8>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<P9>(rt, value.getProperty(rt, "data"), jsInvoker),
      bridging::fromJs<P10>(rt, value.getProperty(rt, "exif"), jsInvoker),
      bridging::fromJs<P11>(rt, value.getProperty(rt, "cropRect"), jsInvoker),
      bridging::fromJs<P12>(rt, value.getProperty(rt, "creationDate"), jsInvoker),
      bridging::fromJs<P13>(rt, value.getProperty(rt, "modificationDate"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String pathToJs(jsi::Runtime &rt, P0 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String localIdentifierToJs(jsi::Runtime &rt, P1 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sourceURLToJs(jsi::Runtime &rt, P2 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String filenameToJs(jsi::Runtime &rt, P3 value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, P4 value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, P5 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String mimeToJs(jsi::Runtime &rt, P6 value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, P7 value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, P8 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String dataToJs(jsi::Runtime &rt, P9 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object exifToJs(jsi::Runtime &rt, P10 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object cropRectToJs(jsi::Runtime &rt, P11 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String creationDateToJs(jsi::Runtime &rt, P12 value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String modificationDateToJs(jsi::Runtime &rt, P13 value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const RNCImageCropPickerBasePickerResponse<P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13> &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    if (value.localIdentifier) {
      result.setProperty(rt, "localIdentifier", bridging::toJs(rt, value.localIdentifier.value(), jsInvoker));
    }
    if (value.sourceURL) {
      result.setProperty(rt, "sourceURL", bridging::toJs(rt, value.sourceURL.value(), jsInvoker));
    }
    if (value.filename) {
      result.setProperty(rt, "filename", bridging::toJs(rt, value.filename.value(), jsInvoker));
    }
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "mime", bridging::toJs(rt, value.mime, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.duration) {
      result.setProperty(rt, "duration", bridging::toJs(rt, value.duration.value(), jsInvoker));
    }
    if (value.data) {
      result.setProperty(rt, "data", bridging::toJs(rt, value.data.value(), jsInvoker));
    }
    if (value.exif) {
      result.setProperty(rt, "exif", bridging::toJs(rt, value.exif.value(), jsInvoker));
    }
    if (value.cropRect) {
      result.setProperty(rt, "cropRect", bridging::toJs(rt, value.cropRect.value(), jsInvoker));
    }
    if (value.creationDate) {
      result.setProperty(rt, "creationDate", bridging::toJs(rt, value.creationDate.value(), jsInvoker));
    }
    if (value.modificationDate) {
      result.setProperty(rt, "modificationDate", bridging::toJs(rt, value.modificationDate.value(), jsInvoker));
    }
    return result;
  }
};


#pragma mark - RNCImageCropPickerPickerOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13, typename P14, typename P15, typename P16, typename P17, typename P18, typename P19, typename P20>
struct RNCImageCropPickerPickerOptions {
  P0 mediaType;
  P1 multiple;
  P2 includeBase64;
  P3 includeExif;
  P4 cropping;
  P5 width;
  P6 height;
  P7 cropperActiveWidgetColor;
  P8 cropperStatusBarLight;
  P9 cropperNavigationBarLight;
  P10 cropperToolbarColor;
  P11 cropperToolbarTitle;
  P12 cropperToolbarWidgetColor;
  P13 cropperCircleOverlay;
  P14 freeStyleCropEnabled;
  P15 showCropGuidelines;
  P16 showCropFrame;
  P17 hideBottomControls;
  P18 enableRotationGesture;
  P19 disableCropperColorSetters;
  P20 useFrontCamera;
  bool operator==(const RNCImageCropPickerPickerOptions &other) const {
    return mediaType == other.mediaType && multiple == other.multiple && includeBase64 == other.includeBase64 && includeExif == other.includeExif && cropping == other.cropping && width == other.width && height == other.height && cropperActiveWidgetColor == other.cropperActiveWidgetColor && cropperStatusBarLight == other.cropperStatusBarLight && cropperNavigationBarLight == other.cropperNavigationBarLight && cropperToolbarColor == other.cropperToolbarColor && cropperToolbarTitle == other.cropperToolbarTitle && cropperToolbarWidgetColor == other.cropperToolbarWidgetColor && cropperCircleOverlay == other.cropperCircleOverlay && freeStyleCropEnabled == other.freeStyleCropEnabled && showCropGuidelines == other.showCropGuidelines && showCropFrame == other.showCropFrame && hideBottomControls == other.hideBottomControls && enableRotationGesture == other.enableRotationGesture && disableCropperColorSetters == other.disableCropperColorSetters && useFrontCamera == other.useFrontCamera;
  }
};

template <typename T>
struct RNCImageCropPickerPickerOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.mediaType)>(rt, value.getProperty(rt, "mediaType"), jsInvoker),
      bridging::fromJs<decltype(types.multiple)>(rt, value.getProperty(rt, "multiple"), jsInvoker),
      bridging::fromJs<decltype(types.includeBase64)>(rt, value.getProperty(rt, "includeBase64"), jsInvoker),
      bridging::fromJs<decltype(types.includeExif)>(rt, value.getProperty(rt, "includeExif"), jsInvoker),
      bridging::fromJs<decltype(types.cropping)>(rt, value.getProperty(rt, "cropping"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.cropperActiveWidgetColor)>(rt, value.getProperty(rt, "cropperActiveWidgetColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperStatusBarLight)>(rt, value.getProperty(rt, "cropperStatusBarLight"), jsInvoker),
      bridging::fromJs<decltype(types.cropperNavigationBarLight)>(rt, value.getProperty(rt, "cropperNavigationBarLight"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarColor)>(rt, value.getProperty(rt, "cropperToolbarColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarTitle)>(rt, value.getProperty(rt, "cropperToolbarTitle"), jsInvoker),
      bridging::fromJs<decltype(types.cropperToolbarWidgetColor)>(rt, value.getProperty(rt, "cropperToolbarWidgetColor"), jsInvoker),
      bridging::fromJs<decltype(types.cropperCircleOverlay)>(rt, value.getProperty(rt, "cropperCircleOverlay"), jsInvoker),
      bridging::fromJs<decltype(types.freeStyleCropEnabled)>(rt, value.getProperty(rt, "freeStyleCropEnabled"), jsInvoker),
      bridging::fromJs<decltype(types.showCropGuidelines)>(rt, value.getProperty(rt, "showCropGuidelines"), jsInvoker),
      bridging::fromJs<decltype(types.showCropFrame)>(rt, value.getProperty(rt, "showCropFrame"), jsInvoker),
      bridging::fromJs<decltype(types.hideBottomControls)>(rt, value.getProperty(rt, "hideBottomControls"), jsInvoker),
      bridging::fromJs<decltype(types.enableRotationGesture)>(rt, value.getProperty(rt, "enableRotationGesture"), jsInvoker),
      bridging::fromJs<decltype(types.disableCropperColorSetters)>(rt, value.getProperty(rt, "disableCropperColorSetters"), jsInvoker),
      bridging::fromJs<decltype(types.useFrontCamera)>(rt, value.getProperty(rt, "useFrontCamera"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String mediaTypeToJs(jsi::Runtime &rt, decltype(types.mediaType) value) {
    return bridging::toJs(rt, value);
  }

  static bool multipleToJs(jsi::Runtime &rt, decltype(types.multiple) value) {
    return bridging::toJs(rt, value);
  }

  static bool includeBase64ToJs(jsi::Runtime &rt, decltype(types.includeBase64) value) {
    return bridging::toJs(rt, value);
  }

  static bool includeExifToJs(jsi::Runtime &rt, decltype(types.includeExif) value) {
    return bridging::toJs(rt, value);
  }

  static bool croppingToJs(jsi::Runtime &rt, decltype(types.cropping) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperActiveWidgetColorToJs(jsi::Runtime &rt, decltype(types.cropperActiveWidgetColor) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperStatusBarLightToJs(jsi::Runtime &rt, decltype(types.cropperStatusBarLight) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperNavigationBarLightToJs(jsi::Runtime &rt, decltype(types.cropperNavigationBarLight) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarColorToJs(jsi::Runtime &rt, decltype(types.cropperToolbarColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarTitleToJs(jsi::Runtime &rt, decltype(types.cropperToolbarTitle) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String cropperToolbarWidgetColorToJs(jsi::Runtime &rt, decltype(types.cropperToolbarWidgetColor) value) {
    return bridging::toJs(rt, value);
  }

  static bool cropperCircleOverlayToJs(jsi::Runtime &rt, decltype(types.cropperCircleOverlay) value) {
    return bridging::toJs(rt, value);
  }

  static bool freeStyleCropEnabledToJs(jsi::Runtime &rt, decltype(types.freeStyleCropEnabled) value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropGuidelinesToJs(jsi::Runtime &rt, decltype(types.showCropGuidelines) value) {
    return bridging::toJs(rt, value);
  }

  static bool showCropFrameToJs(jsi::Runtime &rt, decltype(types.showCropFrame) value) {
    return bridging::toJs(rt, value);
  }

  static bool hideBottomControlsToJs(jsi::Runtime &rt, decltype(types.hideBottomControls) value) {
    return bridging::toJs(rt, value);
  }

  static bool enableRotationGestureToJs(jsi::Runtime &rt, decltype(types.enableRotationGesture) value) {
    return bridging::toJs(rt, value);
  }

  static bool disableCropperColorSettersToJs(jsi::Runtime &rt, decltype(types.disableCropperColorSetters) value) {
    return bridging::toJs(rt, value);
  }

  static bool useFrontCameraToJs(jsi::Runtime &rt, decltype(types.useFrontCamera) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.mediaType) {
      result.setProperty(rt, "mediaType", bridging::toJs(rt, value.mediaType.value(), jsInvoker));
    }
    if (value.multiple) {
      result.setProperty(rt, "multiple", bridging::toJs(rt, value.multiple.value(), jsInvoker));
    }
    if (value.includeBase64) {
      result.setProperty(rt, "includeBase64", bridging::toJs(rt, value.includeBase64.value(), jsInvoker));
    }
    if (value.includeExif) {
      result.setProperty(rt, "includeExif", bridging::toJs(rt, value.includeExif.value(), jsInvoker));
    }
    if (value.cropping) {
      result.setProperty(rt, "cropping", bridging::toJs(rt, value.cropping.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.height) {
      result.setProperty(rt, "height", bridging::toJs(rt, value.height.value(), jsInvoker));
    }
    if (value.cropperActiveWidgetColor) {
      result.setProperty(rt, "cropperActiveWidgetColor", bridging::toJs(rt, value.cropperActiveWidgetColor.value(), jsInvoker));
    }
    if (value.cropperStatusBarLight) {
      result.setProperty(rt, "cropperStatusBarLight", bridging::toJs(rt, value.cropperStatusBarLight.value(), jsInvoker));
    }
    if (value.cropperNavigationBarLight) {
      result.setProperty(rt, "cropperNavigationBarLight", bridging::toJs(rt, value.cropperNavigationBarLight.value(), jsInvoker));
    }
    if (value.cropperToolbarColor) {
      result.setProperty(rt, "cropperToolbarColor", bridging::toJs(rt, value.cropperToolbarColor.value(), jsInvoker));
    }
    if (value.cropperToolbarTitle) {
      result.setProperty(rt, "cropperToolbarTitle", bridging::toJs(rt, value.cropperToolbarTitle.value(), jsInvoker));
    }
    if (value.cropperToolbarWidgetColor) {
      result.setProperty(rt, "cropperToolbarWidgetColor", bridging::toJs(rt, value.cropperToolbarWidgetColor.value(), jsInvoker));
    }
    if (value.cropperCircleOverlay) {
      result.setProperty(rt, "cropperCircleOverlay", bridging::toJs(rt, value.cropperCircleOverlay.value(), jsInvoker));
    }
    if (value.freeStyleCropEnabled) {
      result.setProperty(rt, "freeStyleCropEnabled", bridging::toJs(rt, value.freeStyleCropEnabled.value(), jsInvoker));
    }
    if (value.showCropGuidelines) {
      result.setProperty(rt, "showCropGuidelines", bridging::toJs(rt, value.showCropGuidelines.value(), jsInvoker));
    }
    if (value.showCropFrame) {
      result.setProperty(rt, "showCropFrame", bridging::toJs(rt, value.showCropFrame.value(), jsInvoker));
    }
    if (value.hideBottomControls) {
      result.setProperty(rt, "hideBottomControls", bridging::toJs(rt, value.hideBottomControls.value(), jsInvoker));
    }
    if (value.enableRotationGesture) {
      result.setProperty(rt, "enableRotationGesture", bridging::toJs(rt, value.enableRotationGesture.value(), jsInvoker));
    }
    if (value.disableCropperColorSetters) {
      result.setProperty(rt, "disableCropperColorSetters", bridging::toJs(rt, value.disableCropperColorSetters.value(), jsInvoker));
    }
    if (value.useFrontCamera) {
      result.setProperty(rt, "useFrontCamera", bridging::toJs(rt, value.useFrontCamera.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - RNCImageCropPickerPickerResponse

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct RNCImageCropPickerPickerResponse {
  P0 path;
  P1 localIdentifier;
  P2 sourceURL;
  P3 filename;
  P4 width;
  P5 height;
  P6 mime;
  P7 size;
  P8 duration;
  P9 data;
  P10 exif;
  P11 cropRect;
  P12 creationDate;
  P13 modificationDate;
  bool operator==(const RNCImageCropPickerPickerResponse &other) const {
    return path == other.path && localIdentifier == other.localIdentifier && sourceURL == other.sourceURL && filename == other.filename && width == other.width && height == other.height && mime == other.mime && size == other.size && duration == other.duration && data == other.data && exif == other.exif && cropRect == other.cropRect && creationDate == other.creationDate && modificationDate == other.modificationDate;
  }
};

template <typename T>
struct RNCImageCropPickerPickerResponseBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.path)>(rt, value.getProperty(rt, "path"), jsInvoker),
      bridging::fromJs<decltype(types.localIdentifier)>(rt, value.getProperty(rt, "localIdentifier"), jsInvoker),
      bridging::fromJs<decltype(types.sourceURL)>(rt, value.getProperty(rt, "sourceURL"), jsInvoker),
      bridging::fromJs<decltype(types.filename)>(rt, value.getProperty(rt, "filename"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.mime)>(rt, value.getProperty(rt, "mime"), jsInvoker),
      bridging::fromJs<decltype(types.size)>(rt, value.getProperty(rt, "size"), jsInvoker),
      bridging::fromJs<decltype(types.duration)>(rt, value.getProperty(rt, "duration"), jsInvoker),
      bridging::fromJs<decltype(types.data)>(rt, value.getProperty(rt, "data"), jsInvoker),
      bridging::fromJs<decltype(types.exif)>(rt, value.getProperty(rt, "exif"), jsInvoker),
      bridging::fromJs<decltype(types.cropRect)>(rt, value.getProperty(rt, "cropRect"), jsInvoker),
      bridging::fromJs<decltype(types.creationDate)>(rt, value.getProperty(rt, "creationDate"), jsInvoker),
      bridging::fromJs<decltype(types.modificationDate)>(rt, value.getProperty(rt, "modificationDate"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String pathToJs(jsi::Runtime &rt, decltype(types.path) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String localIdentifierToJs(jsi::Runtime &rt, decltype(types.localIdentifier) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String sourceURLToJs(jsi::Runtime &rt, decltype(types.sourceURL) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String filenameToJs(jsi::Runtime &rt, decltype(types.filename) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String mimeToJs(jsi::Runtime &rt, decltype(types.mime) value) {
    return bridging::toJs(rt, value);
  }

  static double sizeToJs(jsi::Runtime &rt, decltype(types.size) value) {
    return bridging::toJs(rt, value);
  }

  static double durationToJs(jsi::Runtime &rt, decltype(types.duration) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String dataToJs(jsi::Runtime &rt, decltype(types.data) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object exifToJs(jsi::Runtime &rt, decltype(types.exif) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object cropRectToJs(jsi::Runtime &rt, decltype(types.cropRect) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String creationDateToJs(jsi::Runtime &rt, decltype(types.creationDate) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String modificationDateToJs(jsi::Runtime &rt, decltype(types.modificationDate) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "path", bridging::toJs(rt, value.path, jsInvoker));
    if (value.localIdentifier) {
      result.setProperty(rt, "localIdentifier", bridging::toJs(rt, value.localIdentifier.value(), jsInvoker));
    }
    if (value.sourceURL) {
      result.setProperty(rt, "sourceURL", bridging::toJs(rt, value.sourceURL.value(), jsInvoker));
    }
    if (value.filename) {
      result.setProperty(rt, "filename", bridging::toJs(rt, value.filename.value(), jsInvoker));
    }
    result.setProperty(rt, "width", bridging::toJs(rt, value.width, jsInvoker));
    result.setProperty(rt, "height", bridging::toJs(rt, value.height, jsInvoker));
    result.setProperty(rt, "mime", bridging::toJs(rt, value.mime, jsInvoker));
    result.setProperty(rt, "size", bridging::toJs(rt, value.size, jsInvoker));
    if (value.duration) {
      result.setProperty(rt, "duration", bridging::toJs(rt, value.duration.value(), jsInvoker));
    }
    if (value.data) {
      result.setProperty(rt, "data", bridging::toJs(rt, value.data.value(), jsInvoker));
    }
    if (value.exif) {
      result.setProperty(rt, "exif", bridging::toJs(rt, value.exif.value(), jsInvoker));
    }
    if (value.cropRect) {
      result.setProperty(rt, "cropRect", bridging::toJs(rt, value.cropRect.value(), jsInvoker));
    }
    if (value.creationDate) {
      result.setProperty(rt, "creationDate", bridging::toJs(rt, value.creationDate.value(), jsInvoker));
    }
    if (value.modificationDate) {
      result.setProperty(rt, "modificationDate", bridging::toJs(rt, value.modificationDate.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeImageCropPickerCxxSpecJSI : public TurboModule {
protected:
  NativeImageCropPickerCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value openPicker(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value openCamera(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value openCropper(jsi::Runtime &rt, jsi::Object options) = 0;
  virtual jsi::Value clean(jsi::Runtime &rt) = 0;
  virtual jsi::Value cleanSingle(jsi::Runtime &rt, jsi::String path) = 0;

};

template <typename T>
class JSI_EXPORT NativeImageCropPickerCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "RNCImageCropPicker";

protected:
  NativeImageCropPickerCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeImageCropPickerCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeImageCropPickerCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeImageCropPickerCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Value openPicker(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openPicker) == 2,
          "Expected openPicker(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openPicker, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value openCamera(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openCamera) == 2,
          "Expected openCamera(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openCamera, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value openCropper(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::openCropper) == 2,
          "Expected openCropper(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::openCropper, jsInvoker_, instance_, std::move(options));
    }
    jsi::Value clean(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::clean) == 1,
          "Expected clean(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clean, jsInvoker_, instance_);
    }
    jsi::Value cleanSingle(jsi::Runtime &rt, jsi::String path) override {
      static_assert(
          bridging::getParameterCount(&T::cleanSingle) == 2,
          "Expected cleanSingle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::cleanSingle, jsInvoker_, instance_, std::move(path));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
